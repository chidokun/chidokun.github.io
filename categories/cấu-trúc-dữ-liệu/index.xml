<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Cấu trúc dữ liệu on Nguyễn Tuấn&#39;s Blog</title>
    <link>https://chidokun.github.io/categories/c%E1%BA%A5u-tr%C3%BAc-d%E1%BB%AF-li%E1%BB%87u/</link>
    <description>Recent content in Cấu trúc dữ liệu on Nguyễn Tuấn&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>vi</language>
    <lastBuildDate>Thu, 29 Jul 2021 20:17:38 +0700</lastBuildDate><atom:link href="https://chidokun.github.io/categories/c%E1%BA%A5u-tr%C3%BAc-d%E1%BB%AF-li%E1%BB%87u/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Index Priority Queue: Cải tiến Priority Queue</title>
      <link>https://chidokun.github.io/2021/07/index-priority-queue/</link>
      <pubDate>Thu, 29 Jul 2021 20:17:38 +0700</pubDate>
      
      <guid>https://chidokun.github.io/2021/07/index-priority-queue/</guid>
      <description>&lt;p&gt;Ở bài viết &lt;a href=&#34;https://chidokun.github.io/2021/07/priority-queue/&#34;&gt;Priority Queue và những cách cài đặt&lt;/a&gt;, mình đã giới thiệu qua cấu trúc Priority Queue, những đặc trưng và cách cài đặt. Tuy nhiên trong một số trường hợp, chúng ta sẽ có nhu cầu cập nhật hoặc xóa phần tử khỏi Queue thông qua một index. Trong bài viết này chúng ta sẽ cùng cải tiến Priority Queue để có thể thực hiện các chức năng trên.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Priority Queue và những cách cài đặt</title>
      <link>https://chidokun.github.io/2021/07/priority-queue/</link>
      <pubDate>Wed, 14 Jul 2021 18:03:38 +0700</pubDate>
      
      <guid>https://chidokun.github.io/2021/07/priority-queue/</guid>
      <description>&lt;p&gt;Hôm nay chúng ta cùng điểm qua một cấu trúc dữ liệu thuộc dòng họ nhà Queue có một tính chất khá đặc biệt - đẩy vào và lấy ra theo độ ưu tiên - chính là &lt;em&gt;Priority Queue&lt;/em&gt;. Nó có rất nhiều ứng dụng, điển hình là trong &lt;a href=&#34;https://chidokun.github.io/2021/07/huffman-coding-p2/&#34;&gt;Thuật toán nén Huffman Coding&lt;/a&gt; mà mình từng đề cập. Trong bài này chúng ta sẽ đi qua một số cách cài đặt của Priority Queue.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Heap và một số ghi chú</title>
      <link>https://chidokun.github.io/2021/07/heap-note/</link>
      <pubDate>Sun, 11 Jul 2021 12:46:28 +0700</pubDate>
      
      <guid>https://chidokun.github.io/2021/07/heap-note/</guid>
      <description>&lt;p&gt;&lt;em&gt;Heap&lt;/em&gt; được ứng dụng khá nhiều trong các cấu trúc dữ liệu và giải thuật. Nếu bạn đã nghe qua Heap sort thì chắc chắn sẽ làm quen với khái niệm này. Ngoài ra, &lt;em&gt;Heap&lt;/em&gt; cũng còn được ứng dụng trong Prority Queue - một cấu trúc dữ liệu hoạt động theo cơ chế vào trước ra trước. Bài viết này sẽ note một số ý chính về &lt;em&gt;Heap&lt;/em&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Tổng quan về Đồ thị</title>
      <link>https://chidokun.github.io/2021/06/graph-overview/</link>
      <pubDate>Tue, 22 Jun 2021 21:51:01 +0700</pubDate>
      
      <guid>https://chidokun.github.io/2021/06/graph-overview/</guid>
      <description>&lt;p&gt;Cấu trúc &lt;strong&gt;Graph&lt;/strong&gt; (đồ thị) có rất nhiều ứng dụng trong thực tiễn. Bài viết này sẽ note lại tổng quan những điểm chính về việc implement cấu trúc dữ liệu này.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Danh sách liên kết vòng và một số thao tác</title>
      <link>https://chidokun.github.io/2015/08/circular-linked-list/</link>
      <pubDate>Wed, 19 Aug 2015 21:04:00 +0700</pubDate>
      
      <guid>https://chidokun.github.io/2015/08/circular-linked-list/</guid>
      <description>&lt;p&gt;Chúng ta cùng tìm hiểu một cấu trúc dữ liệu cũng khá hữu ích là Danh sách liên kết vòng (Circular Linked List). Nó biểu diễn một cách tự nhiên các cấu trúc dạng tròn như các góc của đa giác, v.v&amp;hellip; DSLK vòng có hai dạng thường thấy là dạng &lt;em&gt;vòng đơn&lt;/em&gt; và &lt;em&gt;vòng kép&lt;/em&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Danh sách liên kết kép và các thao tác cơ bản</title>
      <link>https://chidokun.github.io/2015/08/doubly-linked-list/</link>
      <pubDate>Mon, 17 Aug 2015 22:25:00 +0700</pubDate>
      
      <guid>https://chidokun.github.io/2015/08/doubly-linked-list/</guid>
      <description>&lt;p&gt;Nếu bạn đã đọc bài viết về &lt;a href=&#34;https://chidokun.github.io/2015/07/linked-list/&#34;&gt;Danh sách liên kết đơn&lt;/a&gt; thì có thể thấy việc tổ chức dạng danh sách tiện lợi hơn rất nhiều so với dùng mảng. Tuy nhiên, danh sách liên kết đơn vẫn có nhược điểm là chỉ có thể duyệt từ đầu đến cuối. Vì vậy, một số thao tác sẽ rất khó cài đặt trên nó. Danh sách liên kết kép có thể khắc phục nhược điểm này. Hầu hết các thao tác điều giống với danh sách liên kết đơn nhưng mình cũng khuyên các bạn nên đọc bài viết &lt;a href=&#34;https://chidokun.github.io/2015/07/linked-list/&#34;&gt;Danh sách liên kết đơn và các thao tác cơ bản&lt;/a&gt; trước khi đọc bài viết này. Các thao tác được minh họa bằng C++.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Danh sách liên kết đơn và các thao tác cơ bản</title>
      <link>https://chidokun.github.io/2015/07/linked-list/</link>
      <pubDate>Wed, 08 Jul 2015 22:19:00 +0700</pubDate>
      
      <guid>https://chidokun.github.io/2015/07/linked-list/</guid>
      <description>&lt;p&gt;Danh sách liên kết là một cấu trúc dữ liệu mà mỗi phần tử cần phải lưu thông tin của nó và địa chỉ của phần tử kế tiếp hoặc trước nó. Danh sách liên kết linh động hơn mảng rất nhiều do có thể thêm, xóa phần tử. Có nhiều dạng danh sách liên kết khác nhau và ở phần này mình sẽ nói về danh sách liên kết đơn cùng các thao tác với nó (minh họa bằng C++).&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Cách vẽ lại cây nhị phân tìm kiếm từ kết quả duyệt</title>
      <link>https://chidokun.github.io/2015/06/binary-tree-from-traversal/</link>
      <pubDate>Sat, 13 Jun 2015 14:01:00 +0700</pubDate>
      
      <guid>https://chidokun.github.io/2015/06/binary-tree-from-traversal/</guid>
      <description>&lt;p&gt;Thường có 3 cách duyệt cơ bản là tiền thứ tự (NLR), trung thứ tự (LNR) và hậu thứ tự (LRN). Với kết quả duyệt kiểu NLR và LRN ta có thể vẽ lại cây ban đầu dễ dàng. Còn với LNR, ta không tìm được Node gốc nên không thể vẽ lại cây.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
